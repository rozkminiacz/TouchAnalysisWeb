/**
 * Generating data view and rendering charts
 * Required libraries: dpd.js (deployd autogenerated script), List.js, Papaparse.js, Highcharts.js
 */ 
(function (dpd, List, Papa, Highcharts) {
  
  /**
   * Handler for rendering chart from csv data referenced to list item
   * @param {object} options = {
   *   containerID: (string) Id of element where chart will be rendered
   *   dataList: (object) List.js object with items values stored in 
   *   filesBaseUrl: (string) Base url where files are stored
   *   dataUrlKeyName: (string) Name of key with csv filename  
   *   dataParser: (function) Preprocessor function for csv data (parse data argument into chart series data array)
   *   chartOptions: (object) Highcharts chart options object
   *   onComplete: (function) Callback called every time after chart rendering
   *   manualMode: (bool) Prevent from binding events to list, helpful if you want to call setItem method manually
   * };
   * @returns {object} Self
   */ 
  function dataChartsHandler(options) {
    var self = this;

    // Methods
    self.extend = function (targetObj, sourceObj) {
      for (var key in sourceObj) {
        if (sourceObj.hasOwnProperty(key)) {
          targetObj[key] = sourceObj[key];
        }
      }

      return targetObj;
    };

    self.runItem = function (item) {
      if (self.activeItem === item) {
        return;
      } else if (self.activeItem !== null) {
        self.activeItem.elm.classList.remove('active');
      }
      item.elm.classList.add('active');
      self.activeItem = item;

      self.chart.showLoading();

      var csvUrl = self.opts.filesBaseUrl + item._values[self.opts.dataUrlKeyName];

      Papa.parse(csvUrl, {
        download: true,
        header: true,
        comments: "#",
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function (results) {
          self.csvData = results.data;
          var seriesData = self.opts.dataParser(self.csvData);

          self.chart.hideLoading();

          for (var i = 0; i < seriesData.length; i++) {
            self.chart.series[i].setData(seriesData[i]);
          }

          if (typeof self.opts.onComplete === 'function') {
            self.opts.onComplete(self);
          }
        }
      });
    };


    // Properties
    self.container = document.getElementById(options.containerID);
    self.opts = options;
    self.activeItem = null;
    self.csvData = null;
    self.defaultChartOptions = {
      chart: {
        type: 'line',
        zoomType: 'x',
        height: 300
      },
      credits: {
        enabled: false
      },
      navigation: {
        buttonOptions: {
          verticalAlign: 'bottom'
        }
      },
      series: [{
          data: []
        }]
    };

    // Initialization
    self.chartOptions = self.extend(self.defaultChartOptions, self.opts.chartOptions);
    self.chart = Highcharts.chart(self.container, self.chartOptions);

    if (!self.opts.manualMode) {
      self.opts.dataList.items.forEach(function (item, i) {
        item.elm.addEventListener('click', function (e) {
          self.runItem(item);
        }, false);
      });
    }

    return self;
  }
  
  /**
   * Get data from REST API by dpd.js,
   * generate view by List.js and initialize charts handlers
   */
  var dataName = 'measuredata';
  var baseUrl = dpd.getBaseUrl();
  
  dpd[dataName].get(function (data, err) {
    if (err) {
      return console.error(err);
    }

    var itemTemplate = '<li><h3 class="id"></h3> <div class="info-wrapper">' +
            '<span class="label">User position: </span><span class="position"></span>\n' +
            '<span class="label">Hand: </span><span class="hand"></span>\n' +
            '<span class="label">Finger: </span><span class="finger"></span>\n' +
            '<span class="label">Desired BPM: </span><span class="desiredBPM"></span>\n' +
            '<span class="label">Age: </span><span class="age"></span>\n' +
            '</div></li>';

    var options = {
      valueNames: ['id', 'position', 'hand', 'desiredBPM', 'age', 'finger'],
      item: itemTemplate
    };

    try {
 
      var dataList = new List('data-list-container', options, data);

      var touchDataCharts = new dataChartsHandler({
        dataList: dataList,
        containerID: 'touch-chart-container',
        filesBaseUrl: baseUrl + 'touch/',
        dataUrlKeyName: 'touchURL',
        dataParser: function (data) {
          var series = [];

          if (data.length < 1) {
            return [series];
          }

          var startTime = data[0].eventTime;

          for (var i = 0; i < data.length; i++) {
            var state = (data[i][" type"] === "ACTION_UP") ? 1 : 0;
            var currentTime = data[i].eventTime - startTime;

            series.push([currentTime, state]);

            if (i < data.length - 1) {
              series.push([data[i + 1].eventTime - startTime, state]);
            }
          }

          return [series];
        },
        onComplete: function (handler) {
          accDataCharts.runItem(handler.activeItem);
        },
        chartOptions: {
          title: {
            text: 'Touch state'
          },
          xAxis: {
            title: {
              text: 'Time [ms]'
            },
            crosshair: true
          },
          yAxis: {
            title: {
              text: 'Touch state'
            },
            categories: ['Down', 'Up']
          },
          legend: {
            enabled: false
          },
          tooltip: {
            formatter: function () {
              return '<b>' + this.x + ' ms</b>';
            },
            positioner: function () {
              return {
                x: this.chart.chartWidth - this.label.width, // right aligned
                y: 10
              };
            }
          },
          series: [{
              data: [],
              states: {
                hover: {
                  enabled: false,
                  halo: {
                    size: 0
                  }
                }
              }
            }]
        }
      });

      var touchptsDataCharts = new dataChartsHandler({
        dataList: dataList,
        containerID: 'touchpts-chart-container',
        filesBaseUrl: baseUrl + 'touch/',
        dataUrlKeyName: 'touchURL',
        dataParser: function (data) {
          var series = [];

          if (data.length < 1) {
            return [series];
          }

          var startTime = data[0].eventTime;

          for (var i = 0; i < data.length; i++) {
            var currentTime = data[i].eventTime - startTime;
            
            series.push({
              x: data[i][" x"],
              y: data[i][" y"],
              time: currentTime
            });
          }

          return [series];
        },
        chartOptions: {
          chart: {
            type: 'scatter',
            zoomType: 'xy',
            height: 300
          },
          title: {
            text: 'Touch points'
          },
          xAxis: {
            title: {
              text: 'X-axis [px]'
            },
            min: '200',
            max: '500'
          },
          yAxis: {
            title: {
              text: 'Y-axis [px]'
            },
              min: '600',
              max: '700'
          },
          legend: {
            enabled: false
          },
          tooltip: {
            formatter: function () {
              return '<b>X:</b> ' + this.point.x + ' px<br>' +
                     '<b>Y:</b> ' + this.point.y + ' px<br>' +
                     '<b>Time:</b> ' + this.point.time + ' ms' +
                     '';
            }
          },
          series: [{
              data: []
          }]
        }
      });

      var accDataCharts = new dataChartsHandler({
        dataList: dataList,
        containerID: 'acc-chart-container',
        filesBaseUrl: baseUrl + 'accelerometr/',
        dataUrlKeyName: 'accURL',
        manualMode: true,
        dataParser: function (data) {
          var xSeries = [];
          var ySeries = [];
          var zSeries = [];

          if (data.length < 1 || touchDataCharts.csvData.length < 1) {
            return [xSeries, ySeries, zSeries];
          }

          var startTime = touchDataCharts.csvData[0].eventTime;

          for (var i = 0; i < data.length; i++) {
            var currentTime = data[i].eventTime - startTime;

            xSeries.push([currentTime, data[i][' x']]);
            ySeries.push([currentTime, data[i][' y']]);
            zSeries.push([currentTime, data[i][' z']]);
          }

          return [xSeries, ySeries, zSeries];
        },
        chartOptions: {
          title: {
            text: 'Device acceleration'
          },
          xAxis: {
            title: {
              text: 'Time [ms]'
            },
            crosshair: true
          },
          yAxis: {
            title: {
              text: 'Acceleration [m/s²]'
            }
          },
          tooltip: {
            formatter: function () {
              return '<b>' + this.y + ' m/s² ' + this.x + ' ms</b>';
            },
            positioner: function () {
              return {
                x: this.chart.chartWidth - this.label.width, // right aligned
                y: 10
              };
            }
          },
          series: [{
              name: 'X-axis',
              data: []
            }, {
              name: 'Y-axis',
              data: []
            }, {
              name: 'Z-axis',
              data: []
            }]
        }
      });
     
    } catch (error) {
      console.error(error);
    }

  });
})(dpd, List, Papa, Highcharts);

// Stick charts container to the top of viewport
(function (doc) {
  var stickyMaker = {
    init: function (elm) {
      var self = this;

      self.elm = elm;
      self.updateIntialPos();

      self.stick();

      self.scrollListener = function (e) {
        self.stick.call(self);
      };
      window.addEventListener('scroll', self.scrollListener, false);

      return self;
    },

    stick: function () {
      var self = this;

      if (window.pageYOffset >= self.top) {
        self.elm.style.transform = 'translateY(' + (window.pageYOffset - self.top) + 'px)';
      } else {
        self.elm.style.transform = 'translateY(0px)';
      }
    },

    updateIntialPos: function () {
      var self = this;

      self.top = self.getOffsetTop(self.elm);
    },

    detach: function () {
      var self = this;

      window.removeEventListener('scroll', self.scrollListener, false);
    },

    getOffsetTop: function (element) {
      var posY = element.offsetTop;

      while (element.offsetParent) {
        if (element === document.body) {
          break;
        } else {
          posY = posY + element.offsetParent.offsetTop;
          element = element.offsetParent;
        }
      }

      return posY;
    }
  };

  var chartsContainer = doc.getElementById('charts-container');
  Object.create(stickyMaker).init(chartsContainer);
})(document);
